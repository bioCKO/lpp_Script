#! python
"""
Define files which are used or created in the ICE algorithm,
including temporary results, output files, scripts and logs.
"""
import os.path as op
import logging

from pbcore.util.Process import backticks

from pbtranscript.Utils import real_ppath, now_str, mkdir
from pbtranscript.ice.IceUtils import write_cluster_report
from pbtranscript.io.Summary import write_cluster_summary


class IceFiles(object):

    """Define directories and files used by the ICE algorithm."""

    def __init__(self, prog_name, root_dir,
                 bas_fofn=None, ccs_fofn=None, fasta_fofn=None,
                 no_log_f=False, tmp_dir=None, make_dirs=True):
        """
        prog_name --- name of a sub-class
        root_dir --- root directory of the whole project. There will be
                     sub-directories under it, including:
                     tmp/ --- 0/  c0, c1, ..., c9999
                          --- 1/  c10000, c10001, ..., c19999
                          ...
                          each c? folder contains data for a cluster id=c?
                     script/
                          --- 0/  gcon_job_?.sh, gcon jobs in the first iteration
                          --- 1/  gcon_job_?.sh, gcon jobs in the second iteration
                          ...
                     log/
                          --- ICE.log   Log of the ICE algorithm
                          --- 0/  log for jobs in the first iteration
                          ...
                     output/   output files go here.
        bas_fofn --- input.fofn which contains movie.bas|bax.h5 files.
        ccs_fofn --- a fofn contains movie.ccs.h5 files.
        fasta_fofn --- a fofn contains movie.bax.h5.fasta files.
                     script/
        no_log_f --- DON'T write log to a log file.
        tmp_dir --- Write temporary files to tmp_dir (usually /scratch) for speed
        """
        self.prog_name = str(prog_name)
        self.root_dir = real_ppath(root_dir)
        self._tmp_dir = real_ppath(tmp_dir)

        self.bas_fofn = real_ppath(bas_fofn)
        self.ccs_fofn = real_ppath(ccs_fofn)
        self.fasta_fofn = real_ppath(fasta_fofn)

        if make_dirs is True:
            mkdir(self.root_dir)
            mkdir(self.tmp_dir)
            mkdir(self.log_dir)
            mkdir(self.script_dir)
            mkdir(self.out_dir)

        self.no_log_f = no_log_f
        if not no_log_f:
            self.log_f = open(self.log_fn, 'w', 0)
            self.add_log(msg="{p} initialized.".format(p=self.prog_name))

    @property
    def tmp_dir(self):
        """Return _tmp_dir if not None, else root_dir/tmp."""
        if self._tmp_dir is not None and self._tmp_dir != "":
            return self._tmp_dir
        else:
            return op.join(self.root_dir, "tmp")

    @property
    def log_dir(self):
        """Return $root_dir/log."""
        return op.join(self.root_dir, "log")

    @property
    def log_fn(self):
        """Return $log_dir/$prog_name.log"""
        return op.join(self.log_dir, self.prog_name + ".log")

    @property
    def out_dir(self):
        """Return $root_dir/output."""
        return op.join(self.root_dir, "output")

    @property
    def script_dir(self):
        """Return $root_dir/scripts."""
        return op.join(self.root_dir, "scripts")

    @property
    def nfl_dir(self):
        """Return $root_dir/output/map_noFL"""
        return op.join(self.out_dir, "map_noFL")

    @property
    def quivered_dir(self):
        """Return $root_dir/quivered"""
        return op.join(self.root_dir, "quivered")

    @property
    def quivered_log_dir(self):
        """Return $log_dir/quivered"""
        return op.join(self.log_dir, "quivered")

    @property
    def nfl_all_pickle_fn(self):
        """Return $root_dir/$nfl_dir/nfl.all.partial_uc.pickle,
        this pickle file has all the paitial uc."""
        return op.join(self.nfl_dir, "nfl.all.partial_uc.pickle")

    @property
    def final_consensus_fa(self):
        """Return final consensus Fasta file."""
        return op.join(self.out_dir, "final.consensus.fasta")

    @property
    def final_consensus_sa(self):
        """Return suffix array of the final consensus Fa file."""
        return op.join(self.out_dir, "final.consensus.fasta.sa")

    @property
    def final_pickle_fn(self):
        """Return $root_dir/output/final.pickle"""
        return op.join(self.out_dir, "final.pickle")

    @property
    def final_dazz_db(self):
        """Return final.consensus.dazz.fasta.db"""
        return op.join(self.out_dir, "final.consensus.dazz.fasta.db")

    @property
    def submitted_quiver_jobs_log(self):
        """Return $root_dir/log/submitted_quiver_jobs.txt"""
        return op.join(self.log_dir, 'submitted_quiver_jobs.txt')

    def nfl_fa_i(self, i):
        """Return the i-th splitted chunk of nfl reads.
           $root_dir/output/map_noFL/input.split_{0:03d}.fasta
        """
        fa_name = "input.split_{0:03d}.fasta".format(i)
        return op.join(self.nfl_dir, fa_name)

    def nfl_pickle_i(self, i):
        """Return the picke file of the i-th chunk of nfl reads.
           $nfl_fa_i.partial_uc.pickle
        """
        return self.nfl_fa_i(i) + ".partial_uc.pickle"

    def nfl_done_i(self, i):
        """Return the done file of the i-th chunk of nfl reads.
           $nfl_fa_i.partial_uc.pickle.DONE
        """
        return self.nfl_pickle_i(i) + ".DONE"

    def nfl_script_i(self, i):
        """Return the 'ice_partial' script file of the i-th chunk of nfl reads.
           $nfl_fa_i.partial_uc.sh
        """
        return op.join(self.script_dir,
                       op.basename(self.nfl_pickle_i(i)) + ".partial_uc.sh")

    def cluster_dir(self, cid):
        """Return directory path for the i-th cluster, i in [0,...]"""
        return op.join(self.tmp_dir, str(int(cid) / 10000), 'c' + str(cid))

    def raw_fa_of_cluster(self, cid):
        """Return $cluster_dir/in.raw_with_partial.fasta, which
        contains the unrolled sequence of zmws belonging to cluster
        cid."""
        return op.join(self.cluster_dir(cid), "in.raw_with_partial.fasta")

    def raw_bam_of_cluster(self, cid):
        """Return $cluster_dir/in.raw_with_partial.bam, which
        contains the unrolled sequence of zmws belonging to cluster
        cid."""
        return op.join(self.cluster_dir(cid), "in.raw_with_partial.bam")

    def g_consensus_fa_of_cluster(self, cid):
        """Return $cluster_dir(cid)/g_consensus.fasta.
        Whenever this is changed, the ice_pbdagcon.py command needs
        to be changed accordingly.
        """
        return op.join(self.cluster_dir(cid), "g_consensus.fasta")

    def g_consensus_ref_fa_of_cluster(self, cid):
        """Return $cluster_dir(cid)/g_consensus_ref.fasta.
        Whenever this is changed, the ice_pbdagcon.py command needs
        to be changed accordingly.
        """
        return op.join(self.cluster_dir(cid), "g_consensus_ref.fasta")

    def first_seq_fa_of_cluster(self, cid):
        """Return $cluster_dir(cid)/in.fasta.1stseq.fasta"""
        return op.join(self.cluster_dir(cid), "in.fasta.1stseq.fasta")

    def sam_of_cluster(self, cid):
        """Return $cluster_dir/out.sam.
        This is a a sam file produced by blasr, aligning unrolled sequences
        of reads belonging to this cluster (e.g., in.raw_with_partial.fasta)
        to consensus sequence of this cluster
        (e.g. g_consensus.fasta or
              g_consensus_ref.fasta or
              in.fasta.1stseq.fasta).
        """
        return op.join(self.cluster_dir(cid), "out.sam")

    def bam_of_cluster(self, cid):
        """Return $cluster_dir/out.bam, like sam_of_cluster(cid)."""
        return op.join(self.cluster_dir(cid), "out.bam")

    def add_log(self, msg, level=logging.DEBUG):
        """Add a message to log_f and logging.info|debug|error."""
        msg = "[" + str(self.prog_name) + "] " + msg
        level_name = ""
        if level == logging.INFO:
            level_name = "[INFO]"
            logging.info(msg)
        elif level == logging.ERROR:
            level_name = "[ERROR]"
            logging.error(msg)
        elif level == logging.WARNING:
            level_name = "[WARN]"
            logging.warn(msg)
        else:
            level_name = "[DEBUG]"
            logging.debug(msg)

        if not self.no_log_f:
            self.log_f.write("{t} {ln} {msg}\n".format(
                ln=level_name, t=now_str(), msg=msg))

    def close_log(self):
        """Close log file before exit."""
        self.add_log(self.prog_name + " completed.", level=logging.INFO)
        if not self.no_log_f:
            self.log_f.close()

    def qsub_cmd_and_log(self, cmd):
        """Qsub the given command and write to log, raise a RunTimeError if
        failed to qsub, return qsub job id.

        The error message to display should look like:
            Failed to qsub CMD to SGE: {cmd}, {msg}\n
        """
        msg = "Submitting CMD: {cmd}".format(cmd=cmd)
        self.add_log(msg)
        _out, _code, _msg = backticks(cmd)
        if _code != 0:
            errMsg = "Failed to qsub CMD: {cmd}, {msg}.".\
                format(cmd=cmd, msg=_msg)
            self.add_log(errMsg, level=logging.ERROR)
            raise RuntimeError(errMsg)
        # Your job 596028 ("a.sh") has been submitted
        return str(_out).split()[2]

    def run_cmd_and_log(self, cmd, olog="", elog="", description=""):
        """Run the given command locally and write to log, raise a
        RunTimeError if failed to finish the job.
        olog: output log
        elog: error log

        The error message to display should look like:
            CMD exited with a non-zero code: {cmd}, {msg}\n
            {description}\n
            Error log: {elog}\n
        """
        msg = "Running CMD: {cmd}".format(cmd=cmd)
        self.add_log(msg)
        _out, _code, _msg = backticks(cmd)
        if _code != 0:
            errMsgs = ["CMD exited with a non-zero code: {cmd}, {msg}".
                       format(cmd=cmd, msg=_msg)]
            if len(description) != 0:
                errMsgs.append("{description}".format(description=description))
            if len(elog) != 0:
                errMsgs.append("Error log: {elog}".format(elog=elog))
            if len(olog) != 0:
                errMsgs.append("Out log: {olog}".format(olog=olog))
            errMsg = "\n".join(errMsgs)
            self.add_log(errMsg, level=logging.ERROR)
            raise RuntimeError(errMsg)

    def write_report(self, report_fn, uc, partial_uc=None):
        """
        Write a CSV report to report_fn, each line contains three columns:
            cluster_id, read_id and read_type
        """
        self.add_log("Writing a csv report of cluster -> FL{nfl} reads to {f}".
                     format(nfl="/NonFL" if partial_uc is not None else "",
                            f=report_fn), level=logging.INFO)
        write_cluster_report(report_fn=report_fn, uc=uc, partial_uc=partial_uc)

    def write_summary(self, summary_fn, isoforms_fa, hq_fa=None, lq_fa=None):
        """Extract number of consensus isoforms predicted, and total
        number of bases in all consensuus isoforms from isoforms_fa and write
        the two attributes to summary_fn.

        if hq_fa (polished high-quality isoforms) is not None, report
            the number of polished hq clusters
        if lq_fa (polished high-quality isoforms) is not None, report
            the number of polished hq clusters
        """
        self.add_log("Writing a summary to {f}".format(f=summary_fn),
                     level=logging.INFO)
        write_cluster_summary(summary_fn=summary_fn,
                              isoforms_fa=isoforms_fa,
                              hq_fa=hq_fa,
                              lq_fa=lq_fa)

